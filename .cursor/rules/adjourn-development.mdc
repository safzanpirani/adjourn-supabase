---
description: 
globs: 
alwaysApply: false
---
# ‚ö†Ô∏è HISTORICAL REFERENCE ONLY ‚ö†Ô∏è

**This rule contains the original development guidelines from the beginning of the project (early 2024). For current project information, use these updated rules:**

- **[current-project-architecture.mdc](mdc:.cursor/rules/current-project-architecture.mdc)** - Current project state and architecture
- **[mobile-first-patterns.mdc](mdc:.cursor/rules/mobile-first-patterns.mdc)** - Mobile-first patterns actually implemented
- **[react-query-optimization.mdc](mdc:.cursor/rules/react-query-optimization.mdc)** - Performance optimization system

**The information below is kept for historical context but may not reflect the current implementation.**

---

# Adjourn - Mobile-First Journaling App Development Rules

## Project Overview
Adjourn is a minimalist, typewriter-inspired mobile-first journaling sanctuary with AI companion features. The complete Product Requirements Document is available in [Full-PRD.md](mdc:Full-PRD.md) - **ALWAYS refer to this file** for detailed specifications, design requirements, and technical architecture. The step-by-step development plan is outlined in [plan.md](mdc:plan.md).

## Current Codebase Structure

### Primary Working App: v0-app
The [v0-app](mdc:v0-app) directory contains the **production-ready, fully functional** version with complete Supabase integration. This is the primary codebase to reference and extend.

Key differences:
- **v0-app**: Production-ready with real backend integration, complete hooks, working authentication
- **adjourn-app**: Basic setup, mostly scaffolding - do not prioritize this

### Working Database Schema
Reference [v0-app/types/database.ts](mdc:v0-app/types/database.ts) for the complete TypeScript database schema. Key tables:
- `journals`: User journal containers
- `entries`: Daily journal entries with content
- `images`: Photo attachments with compression
- `streaks`: Writing streak tracking
- `user_preferences`: Theme, mobile settings, etc.

## Core Development Principles

### 1. Mobile-First Excellence
- **Primary Focus**: Mobile experience takes absolute priority over desktop
- **Performance Targets**: 
  - App open (cached): <2s on 3G, <1s on 4G, <0.5s on WiFi
  - Time to interactive: <4s on 3G, <2s on 4G, <1.5s on WiFi
  - Auto-save: <500ms on 3G, <200ms on 4G, <100ms on WiFi
- **Touch Optimization**: Minimum 44x44px touch targets, haptic feedback, gesture navigation
- **PWA Requirements**: Installable, offline-capable, native-feeling interactions

### 2. Tech Stack (Strictly Follow)
```yaml
Frontend:
  - Framework: Next.js 14 (App Router) with PWA support
  - Styling: Tailwind CSS with mobile-first utilities
  - State: Zustand with persistence
  - Data: React Query with offline support
  - Images: react-dropzone + browser-image-compression (lossless WebP)
  - Dates: date-fns
  - Markdown: react-markdown
  - PWA: next-pwa
  - Gestures: react-swipeable
  - Viewport: react-viewport-height

Backend:
  - Database: Supabase (PostgreSQL)
  - Auth: Supabase Auth (Magic Links + Biometric)
  - Storage: Supabase Storage
  - Functions: Supabase Edge Functions (Deno)
  - AI: Google Gemini 2.5 Flash

Deployment:
  - Frontend: Vercel with Edge Network
  - Backend: Supabase Cloud
```

### 3. Design System (Reference [Full-PRD.md](mdc:Full-PRD.md) for complete specs)
```css
/* Mobile-First Color Palette */
--background: #FAFAF8;      /* Off-white */
--text-primary: #2A2A2A;    /* Charcoal */
--accent: #5D6D4E;          /* Muted olive */
--secondary: #8B8680;       /* Warm gray */
--success: #7FA66D;         /* Soft green */

/* Typography */
--font-primary: 'IBM Plex Mono', 'Courier Prime', monospace;
--font-size-base-mobile: 15px;
--font-size-base-desktop: 16px;

/* Mobile-First Layout */
--touch-target-min: 44px;
--spacing-unit: 8px;
--safe-area-inset: env(safe-area-inset-bottom);
```

### 4. Critical User Experience Requirements

#### **AESTHETICS & UX ARE PARAMOUNT** üé®
- Every component must feel delightful and polished
- Typewriter-inspired nostalgia with modern minimalism
- Smooth animations and transitions (60fps target)
- **Ask for feedback frequently** - user experience validation is crucial
- Test interactions on actual mobile devices, not just browser dev tools

#### Mobile Editor Excellence
- Auto-focus cursor when opening entry
- Viewport adjusts for keyboard height
- Formatting toolbar above keyboard with large touch targets
- Auto-save with minimal indicator
- Voice-to-text integration
- Gesture navigation (swipe left/right for prev/next day)

#### Polaroid Memories
- Direct camera access with batch upload (up to 5 photos)
- Lossless WebP conversion, max 1200px wide for mobile
- Single column swipeable carousel
- Pinch to zoom, swipe up for captions
- Haptic feedback on interactions

## Database Architecture & Patterns

### 1. Supabase Configuration
Follow the pattern in [v0-app/lib/supabase.ts](mdc:v0-app/lib/supabase.ts):

```typescript
export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
})
```

### 2. Database Schema Patterns
- All tables use UUIDs for primary keys
- `created_at` and `updated_at` timestamps on all tables
- `user_id` foreign key with RLS policies
- Mobile-specific fields: `device_type`, `haptic_enabled`, `mobile_keyboard_toolbar`
- Proper indexing on date fields and user queries

### 3. Row Level Security (RLS)
Every table must have RLS policies:
```sql
-- Example pattern for entries table
CREATE POLICY "Users can view own entries" ON entries
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own entries" ON entries
  FOR INSERT WITH CHECK (auth.uid() = user_id);
```

## Hook Architecture & Patterns

### 1. Custom Hook Structure
Follow the pattern established in [v0-app/hooks/](mdc:v0-app/hooks):

#### Base Hook Pattern:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { supabase } from '@/lib/supabase'
import { useAuth } from './useAuth'
import type { Database } from '@/types/database'

export const useDataHook = () => {
  const { user } = useAuth()
  const [data, setData] = useState([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Fetch, create, update, delete methods
  // Always include optimistic updates
  // Handle authentication state
  
  return {
    data,
    loading,
    error,
    // CRUD methods
  }
}
```

### 2. Essential Hooks Reference
- [useAuth.ts](mdc:v0-app/hooks/useAuth.ts): Authentication state and magic link
- [useEntries.ts](mdc:v0-app/hooks/useEntries.ts): Journal entries CRUD with auto-save
- [useJournals.ts](mdc:v0-app/hooks/useJournals.ts): Journal containers management
- [useImages.ts](mdc:v0-app/hooks/useImages.ts): Image upload with compression
- [useStreaks.ts](mdc:v0-app/hooks/useStreaks.ts): Writing streak tracking

### 3. Hook Best Practices
- Always handle loading and error states
- Implement optimistic updates for better UX
- Use TypeScript with proper Database types
- Include cleanup in useEffect hooks
- Handle authentication dependency properly

## Component Architecture & Patterns

### 1. Mobile-First Component Structure
Follow patterns from [v0-app/components/](mdc:v0-app/components):

```typescript
"use client"

import { ComponentProps } from 'react'
import { Button } from "@/components/ui/button"

interface MobileComponentProps {
  currentPage?: string
  // Props with defaults for mobile
}

export function MobileComponent({ currentPage }: MobileComponentProps) {
  // Mobile-first logic
  
  return (
    <div className="md:hidden fixed bottom-0 left-0 right-0">
      {/* Mobile layout */}
    </div>
  )
}
```

### 2. Key Component Patterns
- [bottom-navigation.tsx](mdc:v0-app/components/bottom-navigation.tsx): Mobile navigation with active states
- [polaroid-gallery.tsx](mdc:v0-app/components/polaroid-gallery.tsx): Swipeable photo carousel
- [desktop-sidebar.tsx](mdc:v0-app/components/desktop-sidebar.tsx): Responsive desktop navigation

### 3. UI Component Standards
- Use shadcn/ui components from [v0-app/components/ui/](mdc:v0-app/components/ui)
- Always include proper TypeScript interfaces
- Implement proper accessibility (ARIA labels, keyboard navigation)
- Follow mobile-first responsive patterns

## Page Architecture & Routing

### 1. Next.js App Router Structure
Follow the established pattern in [v0-app/app/](mdc:v0-app/app):

```typescript
"use client"

import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import { useAuth } from "@/hooks/useAuth"

export default function PageComponent() {
  const { user, loading: authLoading, isAuthenticated } = useAuth()
  
  // Redirect if not authenticated
  useEffect(() => {
    if (!authLoading && !isAuthenticated) {
      router.push('/')
    }
  }, [authLoading, isAuthenticated, router])

  // Show loading state
  if (authLoading) {
    return <LoadingSpinner />
  }

  // Don't render if not authenticated
  if (!isAuthenticated) {
    return null
  }

  return <PageContent />
}
```

### 2. Route Protection Pattern
- Always check authentication status
- Redirect unauthenticated users to home
- Show loading states during auth checks
- Don't render protected content until auth confirmed

## Auto-Save & Data Persistence

### 1. Auto-Save Implementation
Follow the pattern in [v0-app/app/today/page.tsx](mdc:v0-app/app/today/page.tsx):

```typescript
// Debounced auto-save
const debouncedSave = useCallback(async (contentToSave: string) => {
  if (!user || contentToSave === lastSavedContentRef.current) return
  
  setIsSaving(true)
  try {
    const result = await autoSave(contentToSave)
    if (result.success) {
      setLastSaved(new Date())
      lastSavedContentRef.current = contentToSave
    }
  } finally {
    setIsSaving(false)
  }
}, [user, autoSave])

// Auto-save on content change
const handleContentChange = (newContent: string) => {
  setContent(newContent)
  contentRef.current = newContent
  
  if (saveTimeoutRef.current) {
    clearTimeout(saveTimeoutRef.current)
  }
  
  saveTimeoutRef.current = setTimeout(() => {
    debouncedSave(contentRef.current)
  }, 2000) // Save after 2 seconds of inactivity
}
```

### 2. Auto-Save Best Practices
- Use refs to avoid unnecessary re-renders
- Implement debouncing (2 second delay)
- Save on blur events
- Show save status indicators
- Don't save if content unchanged

## Image Handling & Compression

### 1. Image Upload Pattern
Follow [v0-app/hooks/useImages.ts](mdc:v0-app/hooks/useImages.ts) and [v0-app/lib/imageCompression.ts](mdc:v0-app/lib/imageCompression.ts):

```typescript
// Compress and upload
const compressedFile = await compressImage(file, {
  maxSizeMB: 2,
  maxWidthOrHeight: 1200,
  useWebWorker: true,
  fileType: 'image/webp'
})

// Upload to Supabase Storage
const { data, error } = await supabase.storage
  .from('entry-images')
  .upload(storagePath, compressedFile)
```

### 2. Image Best Practices
- Always compress to WebP format
- Maximum 1200px width for mobile
- Use Supabase Storage with proper RLS
- Implement proper loading states
- Handle upload progress feedback

## Development Standards

### 1. Code Quality Requirements
- TypeScript everywhere - no `any` types
- ESLint + Prettier with strict rules
- Component composition over inheritance
- Custom hooks for mobile-specific logic
- Comprehensive error boundaries

### 2. File Organization
```
v0-app/
‚îú‚îÄ‚îÄ app/                    # Next.js 14 App Router pages
‚îú‚îÄ‚îÄ components/            # Reusable components
‚îÇ   ‚îú‚îÄ‚îÄ ui/               # shadcn/ui components
‚îÇ   ‚îî‚îÄ‚îÄ [feature].tsx     # Feature-specific components
‚îú‚îÄ‚îÄ hooks/                # Custom hooks
‚îú‚îÄ‚îÄ lib/                  # Utilities and configurations
‚îú‚îÄ‚îÄ types/                # TypeScript definitions
‚îî‚îÄ‚îÄ styles/               # Global styles
```

### 3. Naming Conventions
- Components: PascalCase (`MobileEditor.tsx`)
- Hooks: camelCase starting with 'use' (`useMobileKeyboard.ts`)
- Utilities: camelCase (`imageCompressor.ts`)
- Database types: Follow Supabase generated types
- CSS variables: kebab-case with `--` prefix

## Authentication & Security

### 1. Magic Link Authentication
Follow [v0-app/hooks/useAuth.ts](mdc:v0-app/hooks/useAuth.ts) pattern:

```typescript
const sendMagicLink = async (email: string) => {
  const { error } = await supabase.auth.signInWithOtp({
    email,
    options: {
      shouldCreateUser: true,
      emailRedirectTo: `${window.location.origin}/today`
    }
  })
  // Handle result
}
```

### 2. Security Best Practices
- Always validate user authentication
- Use RLS policies on all tables
- Sanitize user inputs
- Implement proper CORS settings
- Use environment variables for secrets

## Performance & Optimization

### 1. Bundle Size Targets
- Initial bundle: <2MB
- Individual pages: <500KB
- Images: Compressed WebP, <1MB each
- Fonts: Subset and preload critical fonts

### 2. Loading Strategies
- Code splitting by route and feature
- Lazy loading for images with blur-up effect
- Preload critical resources
- Service worker caching strategy

### 3. Mobile Performance
- Target 60fps animations
- Minimize JavaScript execution during scrolling
- Use CSS transforms for animations
- Implement virtual scrolling for long lists

## Error Handling & User Feedback

### 1. Error Boundary Pattern
```typescript
'use client'

import { Component, ReactNode } from 'react'

export class ErrorBoundary extends Component {
  // Implement proper error catching and user feedback
}
```

### 2. User Feedback Standards
- Loading spinners for async operations
- Toast notifications for actions
- Progress indicators for uploads
- Clear error messages with retry options
- Haptic feedback for mobile interactions

## Testing Requirements

### 1. Critical Test Scenarios
- Authentication flow (magic link)
- Auto-save functionality
- Image upload and compression
- Offline mode and sync
- Mobile keyboard interactions
- Touch gestures and navigation

### 2. Device Testing
- iOS: iPhone 12 mini to 15 Pro Max
- Android: Pixel 4a+, Samsung Galaxy series
- Progressive enhancement for older devices
- Test on actual devices, not just browser dev tools

## AI Integration Patterns

### 1. AI Writing Assistant
Follow [v0-app/hooks/useAI.ts](mdc:v0-app/hooks/useAI.ts) for AI integration:

```typescript
// Google Gemini integration
const generateResponse = async (prompt: string) => {
  const response = await streamText({
    model: google('gemini-2.0-flash-exp'),
    messages: [{ role: 'user', content: prompt }],
  })
  // Handle streaming response
}
```

### 2. AI Best Practices
- Use streaming for real-time responses
- Implement proper rate limiting
- Handle API errors gracefully
- Cache responses when appropriate
- Provide fallback options

## Key Success Metrics

### 1. Performance Targets
- [ ] App loads in <2s on 4G
- [ ] Auto-save completes in <500ms
- [ ] Images upload with progress indicators
- [ ] 60fps scrolling and animations
- [ ] <5% battery drain per hour active use

### 2. User Experience Goals
- [ ] One-thumb navigation possible
- [ ] Keyboard never covers writing area
- [ ] Haptic feedback enhances interactions
- [ ] Works fully offline for 7+ days
- [ ] Native app-like feel on mobile

## Development Workflow

### 1. Git Workflow
- Feature branches: `feature/mobile-editor`
- Conventional commits: `feat(mobile): add keyboard toolbar`
- PR reviews required for main branch
- Deploy previews for all PRs

### 2. Development Environment
- Use [v0-app](mdc:v0-app) as primary codebase
- Reference [Full-PRD.md](mdc:Full-PRD.md) for specifications
- Follow [plan.md](mdc:plan.md) for development phases
- Test on real mobile devices regularly

## Emergency Contacts & Resources
- PRD Reference: [Full-PRD.md](mdc:Full-PRD.md)
- Development Plan: [plan.md](mdc:plan.md)
- Working Codebase: [v0-app/](mdc:v0-app)
- Database Schema: [v0-app/types/database.ts](mdc:v0-app/types/database.ts)
- Supabase Config: [v0-app/lib/supabase.ts](mdc:v0-app/lib/supabase.ts)

---

**Remember: The goal is creating the most delightful mobile journaling experience possible. The v0-app contains the working production-ready code - always reference it for patterns and implementations. Aesthetics and user experience are paramount. When in doubt, prioritize the mobile user's needs and ask for feedback early and often.** üì±‚ú®

