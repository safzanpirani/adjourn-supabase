---
description: 
globs: 
alwaysApply: true
---
# Adjourn - Supabase React Query Optimization System

**This rule documents the Supabase-optimized React Query caching system designed to minimize egress and maximize performance.**

## ðŸš¨ CRITICAL: Egress Cost Control

**Our #1 priority is preventing excessive Supabase egress (7GB in 12 hours is unacceptable for a 5GB monthly limit).**

### Egress Reduction Strategies
1. **Selective Data Fetching**: Only fetch what's needed, when needed
2. **Aggressive Local Caching**: Use localStorage and React Query cache extensively
3. **Batch Operations**: Combine multiple requests into single calls
4. **CDN-First Images**: Always use Supabase Storage CDN URLs with proper caching
5. **RLS Optimization**: Write efficient Row Level Security queries

## Core Configuration

### Query Client Setup - [queryClient.ts](mdc:lib/queryClient.ts)
```typescript
export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 15 * 60 * 1000, // 15 minutes - LONGER to reduce refetches
      gcTime: 60 * 60 * 1000,    // 1 hour - keep cached longer
      retry: 2, // Reduce retries to save egress
      refetchOnWindowFocus: false, // CRITICAL: Don't refetch on focus
      refetchOnReconnect: 'always', // Only on actual reconnect
      refetchOnMount: false, // Use cache first
    },
    mutations: {
      retry: 1, // Reduce mutation retries
    },
  },
})
```

### Supabase Client Configuration - [supabase.ts](mdc:lib/supabase.ts)
```typescript
export const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  {
    db: {
      schema: 'public',
    },
    auth: {
      persistSession: true,
      storageKey: 'adjourn-auth',
      storage: typeof window !== 'undefined' ? window.localStorage : undefined,
    },
    realtime: {
      params: {
        eventsPerSecond: 2, // Limit realtime events to reduce egress
      },
    },
  }
)
```

## Egress-Optimized Hook Architecture

### Main Export Hook - [useOptimizedHooks.ts](mdc:hooks/useOptimizedHooks.ts)
**ALWAYS use this export for egress-optimized access:**
```typescript
export { useAuth } from './useAuth'
export { useEntriesOptimized as useEntries } from './useEntriesOptimized'
export { useJournalsOptimized as useJournals } from './useJournalsOptimized'
export { useStreaksOptimized as useStreaks } from './useStreaksOptimized'
export { useTodayEntryOptimized as useTodayEntry } from './useTodayEntryOptimized'
```

## Supabase-Specific Optimizations

### Selective Realtime Subscriptions
```typescript
// ONLY subscribe to data actively being edited
const useEntryRealtime = (entryId: string, isActive: boolean) => {
  useEffect(() => {
    if (!isActive) return // Don't subscribe unless actively editing
    
    const subscription = supabase
      .channel(`entry-${entryId}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'entries',
        filter: `id=eq.${entryId}`,
      }, (payload) => {
        // Update cache only for the specific entry
        queryClient.setQueryData(['entry', entryId], payload.new)
      })
      .subscribe()
    
    return () => subscription.unsubscribe()
  }, [entryId, isActive])
}
```

### Optimized Entry Queries - [useEntriesOptimized.ts](mdc:hooks/useEntriesOptimized.ts)
```typescript
export const useEntriesOptimized = (journalId: string) => {
  const { data: user } = useAuth()
  
  // CRITICAL: Use select to limit columns and reduce egress
  return useQuery({
    queryKey: ['entries', user?.id, journalId],
    queryFn: async () => {
      const { data, error } = await supabase
        .from('entries')
        .select('id, title, content, created_at, word_count, date_key') // Only needed columns
        .eq('journal_id', journalId)
        .eq('user_id', user?.id)
        .order('created_at', { ascending: false })
        .limit(50) // Limit results to prevent massive fetches
      
      if (error) throw error
      return data
    },
    enabled: !!user?.id && !!journalId,
    staleTime: 15 * 60 * 1000, // 15 minutes before considering stale
  })
}
```

### Calendar View Optimization - [useCalendarData.ts](mdc:hooks/useCalendarData.ts)
```typescript
// For calendar views, only fetch aggregated data, not full entries
export const useCalendarData = (year: number, month: number) => {
  const { data: user } = useAuth()
  
  return useQuery({
    queryKey: ['calendar', user?.id, year, month],
    queryFn: async () => {
      // CRITICAL: Only fetch date_key and counts, not full content
      const { data, error } = await supabase
        .from('entries')
        .select('date_key, word_count, id') // Minimal data for calendar
        .eq('user_id', user?.id)
        .gte('date_key', `${year}-${month.toString().padStart(2, '0')}-01`)
        .lt('date_key', `${year}-${(month + 1).toString().padStart(2, '0')}-01`)
      
      if (error) throw error
      
      // Transform to calendar format locally
      return data.reduce((acc, entry) => {
        acc[entry.date_key] = {
          hasEntry: true,
          wordCount: entry.word_count,
          entryId: entry.id,
        }
        return acc
      }, {} as Record<string, { hasEntry: boolean; wordCount: number; entryId: string }>)
    },
    enabled: !!user?.id,
    staleTime: 30 * 60 * 1000, // 30 minutes for calendar data
  })
}
```

### Image Handling Optimization
```typescript
// CRITICAL: Use Supabase Storage CDN URLs with proper caching
export const useImageUrl = (imagePath: string) => {
  return useQuery({
    queryKey: ['image-url', imagePath],
    queryFn: async () => {
      const { data } = supabase.storage
        .from('entry-images')
        .getPublicUrl(imagePath, {
          transform: {
            width: 800, // Specify size to use CDN transforms
            height: 600,
            resize: 'contain',
          },
        })
      
      return data.publicUrl
    },
    enabled: !!imagePath,
    staleTime: 24 * 60 * 60 * 1000, // 24 hours for image URLs
    gcTime: 7 * 24 * 60 * 60 * 1000, // Keep for 7 days
  })
}
```

## Optimistic Updates with Rollback

### Entry Update Pattern
```typescript
const updateEntry = useMutation({
  mutationFn: async ({ id, updates }: { id: string; updates: Partial<Entry> }) => {
    const { data, error } = await supabase
      .from('entries')
      .update(updates)
      .eq('id', id)
      .eq('user_id', user?.id) // RLS in query for safety
      .select()
      .single()
    
    if (error) throw error
    return data
  },
  onMutate: async (variables) => {
    // Cancel refetch and snapshot previous value
    await queryClient.cancelQueries({ queryKey: ['entry', variables.id] })
    const previousEntry = queryClient.getQueryData(['entry', variables.id])
    
    // Optimistically update cache
    queryClient.setQueryData(['entry', variables.id], (old: any) => ({
      ...old,
      ...variables.updates,
    }))
    
    return { previousEntry }
  },
  onError: (err, variables, context) => {
    // Rollback on error
    if (context?.previousEntry) {
      queryClient.setQueryData(['entry', variables.id], context.previousEntry)
    }
  },
  onSettled: (data, error, variables) => {
    // Only invalidate on success to prevent unnecessary refetches
    if (!error) {
      queryClient.invalidateQueries({ queryKey: ['entries'] })
    }
  }
})
```

## localStorage Persistence Strategy

### Critical Data Persistence
```typescript
// Persist critical data to survive page refreshes
export const persistCriticalData = () => {
  const persistedQueries = [
    'journals',
    'today-entry',
    'user-settings',
  ]
  
  persistedQueries.forEach(queryKey => {
    const data = queryClient.getQueryData([queryKey])
    if (data) {
      localStorage.setItem(`adjourn-cache-${queryKey}`, JSON.stringify(data))
    }
  })
}
```

## Query Key Patterns for Consistency

### Standard Key Structure
```typescript
// User-scoped queries (most common)
['entries', userId, journalId]
['journals', userId]
['streaks', userId]
['today-entry', userId, dateKey]

// Global/cached queries
['image-url', imagePath]
['calendar', userId, year, month]
```

## Development Guidelines for Egress Prevention

### DO: Egress-Friendly Patterns
1. **Select specific columns**: Never use `select('*')`
2. **Limit results**: Always use `.limit()` for lists
3. **Cache aggressively**: Use long `staleTime` values
4. **Batch operations**: Combine multiple updates into single calls
5. **Use CDN transforms**: Let Supabase Storage resize images
6. **Minimal realtime**: Only subscribe to actively edited data

### DON'T: Egress-Heavy Anti-Patterns
1. **Never refetch on focus**: `refetchOnWindowFocus: false`
2. **Don't over-subscribe**: Avoid unnecessary realtime subscriptions
3. **Don't fetch full content for lists**: Use minimal columns for overview data
4. **Don't retry excessively**: Limit retry attempts
5. **Don't invalidate broadly**: Target specific query keys

### RLS Query Optimization
```sql
-- Good: Efficient RLS with proper indexing
CREATE INDEX idx_entries_user_date ON entries(user_id, date_key);

-- Query pattern in hooks:
.eq('user_id', user.id) -- Always filter by user_id first
.eq('journal_id', journalId) -- Then by journal_id
.order('created_at', { ascending: false })
.limit(50) -- Always limit
```

## Monitoring and Debugging

### Egress Monitoring Component - [egress-monitor.tsx](mdc:components/egress-monitor.tsx)
```typescript
// Development component to track data usage
export const EgressMonitor = () => {
  const [requestCount, setRequestCount] = useState(0)
  const [dataTransferred, setDataTransferred] = useState(0)
  
  // Track all Supabase requests in development
  useEffect(() => {
    if (process.env.NODE_ENV === 'development') {
      // Monitor network requests and estimate egress
    }
  }, [])
  
  return (
    <div className="fixed bottom-4 right-4 bg-yellow-100 p-2 rounded text-xs">
      <div>Requests: {requestCount}</div>
      <div>Estimated egress: {dataTransferred}KB</div>
    </div>
  )
}
```

## Authentication Integration

### Google OAuth + Email/Password Setup
```typescript
// Replace magic link with Google OAuth and email/password
export const useAuth = () => {
  return useQuery({
    queryKey: ['auth'],
    queryFn: async () => {
      const { data: { user } } = await supabase.auth.getUser()
      return user
    },
    staleTime: 5 * 60 * 1000, // 5 minutes for auth data
  })
}

export const signInWithGoogle = async () => {
  const { error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${window.location.origin}/auth/callback`,
    },
  })
  if (error) throw error
}

export const signInWithEmail = async (email: string, password: string) => {
  const { error } = await supabase.auth.signInWithPassword({
    email,
    password,
  })
  if (error) throw error
}
```

---

**Remember: Every query should be designed with egress cost in mind. When in doubt, fetch less data and cache longer.**

